# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

name: python-maturin
description: Build/test/publish Python package with maturin
inputs:
  task:
    description: "Task to run"
    required: true
  version:
    description: "Version for publishing"
    required: false
    default: ""
  dry_run:
    description: "Dry run mode"
    required: false
    default: "false"

runs:
  using: "composite"
  steps:
    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: "3.11"

    - name: Setup Rust
      shell: bash
      run: |
        echo "Using toolchain from rust-toolchain.toml: $(rustup show)"

    - name: Cache Rust dependencies
      uses: Swatinem/rust-cache@v2
      with:
        workspaces: |
          . -> target
          foreign/python -> target
        cache-on-failure: true
        key: python-${{ inputs.task }}

    - name: Cache pip
      uses: actions/cache@v4
      with:
        path: ~/.cache/pip
        key: pip-${{ runner.os }}-${{ hashFiles('foreign/python/pyproject.toml') }}

    - name: Install dependencies
      shell: bash
      run: |
        python -m pip install --upgrade pip wheel setuptools
        
        # Install maturin for building
        pip install 'maturin>=1.2,<2.0'
        
        # Install testing dependencies from pyproject.toml
        cd foreign/python
        pip install -e ".[testing,examples,dev]"
        cd ../..
        
        # Install additional CI dependencies for Docker testing if needed
        if [ "${{ inputs.task }}" = "test" ]; then
          pip install 'testcontainers[docker]>=3.7.0,<5.0' || true
        fi

    - name: Lint and format check
      if: inputs.task == 'lint'
      shell: bash
      run: |
        cd foreign/python
        
        # Check which directories exist and lint them
        DIRS_TO_CHECK="src/ tests/"
        if [ -d "python_examples" ]; then
          DIRS_TO_CHECK="$DIRS_TO_CHECK python_examples/"
        elif [ -d "examples" ]; then
          DIRS_TO_CHECK="$DIRS_TO_CHECK examples/"
        fi
        
        # Run ruff linter
        ruff check $DIRS_TO_CHECK || true
        
        # Check black formatting
        black --check $DIRS_TO_CHECK || true
        
        # Check import sorting
        isort --check-only $DIRS_TO_CHECK || true
        
        # Type checking with mypy
        mypy src/ || true

    - name: Test
      if: inputs.task == 'test'
      shell: bash
      run: |
        cd foreign/python

        # Build the module for testing (same approach as old CI and Docker)
        echo "Building Python wheel..."
        maturin build --release -o dist
        
        # Install the built wheel
        echo "Installing built wheel..."
        pip install dist/*.whl --force-reinstall

        # Set up Docker if available
        if command -v docker &> /dev/null && [ -f "docker-compose.test.yml" ]; then
          echo "Running tests with Docker Compose..."
          
          # Ensure Docker daemon is running
          if docker info &> /dev/null; then
            # Set up Docker Buildx if not already done
            docker buildx version || docker buildx create --use
            
            # Run tests with Docker
            DOCKER_BUILDKIT=1 docker compose -f docker-compose.test.yml up \
              --build --abort-on-container-exit --exit-code-from python-tests
            
            # Capture exit code
            TEST_EXIT_CODE=$?
            
            # Clean up
            docker compose -f docker-compose.test.yml down -v || true
            
            # Exit with test result
            exit $TEST_EXIT_CODE
          else
            echo "Docker daemon not running, falling back to direct tests"
            pytest tests/ -v --junitxml=../../reports/python-junit.xml
          fi
        else
          echo "Docker not available or docker-compose.test.yml not found"
          echo "Running tests directly..."
          
          # Create symlink for examples directory if needed
          if [ -d "python_examples" ] && [ ! -e "examples" ]; then
            ln -s python_examples examples
          fi
          
          # Start server in background if possible
          if [ -f "../../target/debug/iggy-server" ] || [ -f "../../target/release/iggy-server" ]; then
            echo "Starting Iggy server in background..."
            
            # Use release build if available, otherwise debug
            if [ -f "../../target/release/iggy-server" ]; then
              ../../target/release/iggy-server &
            else
              ../../target/debug/iggy-server &
            fi
            SERVER_PID=$!
            
            # Wait for server to be ready
            echo "Waiting for server to start..."
            for i in {1..30}; do
              if timeout 1 bash -c '</dev/tcp/localhost/8090' 2>/dev/null; then
                echo "Server is ready!"
                break
              fi
              sleep 1
            done
            
            # Run tests
            IGGY_SERVER_HOST=127.0.0.1 IGGY_SERVER_TCP_PORT=8090 \
              pytest tests/ -v --junitxml=../../reports/python-junit.xml || TEST_EXIT_CODE=$?
            
            # Kill server
            kill $SERVER_PID 2>/dev/null || true
            
            exit ${TEST_EXIT_CODE:-0}
          else
            echo "No Iggy server binary found, running unit tests only"
            pytest tests/ -v -m "not integration" --junitxml=../../reports/python-junit.xml || true
          fi
        fi

    - name: Build wheels
      if: inputs.task == 'build' || inputs.task == 'publish'
      shell: bash
      run: |
        cd foreign/python

        # Build wheels for multiple Python versions
        # Note: Only build for versions available in the runner
        PYTHON_VERSIONS=""
        for py_ver in python3.8 python3.9 python3.10 python3.11 python3.12; do
          if command -v $py_ver &> /dev/null; then
            PYTHON_VERSIONS="$PYTHON_VERSIONS $py_ver"
          fi
        done
        
        if [ -z "$PYTHON_VERSIONS" ]; then
          echo "Building for default Python version"
          maturin build --release -o dist
        else
          echo "Building for Python versions:$PYTHON_VERSIONS"
          maturin build --release --interpreter $PYTHON_VERSIONS -o dist
        fi

        # Build source distribution
        maturin sdist -o dist

        # List built artifacts
        ls -la dist/

    - name: Publish to PyPI
      if: inputs.task == 'publish'
      shell: bash
      env:
        MATURIN_PYPI_TOKEN: ${{ env.PYPI_API_TOKEN }}
      run: |
        cd foreign/python

        if [ "${{ inputs.dry_run }}" = "true" ]; then
          echo "Dry run - would publish these files:"
          ls -la dist/
        else
          # Try OIDC first (Trusted Publisher)
          if [ -n "$ACTIONS_ID_TOKEN_REQUEST_TOKEN" ]; then
            echo "Using OIDC authentication"
            maturin upload dist/* --skip-existing
          elif [ -n "$MATURIN_PYPI_TOKEN" ]; then
            echo "Using token authentication"
            maturin upload dist/* --skip-existing
          else
            echo "No PyPI credentials found"
            exit 1
          fi
        fi